[
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = d_from_current + d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 8,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    ALPHA = 0.6  # Tunable parameter balancing local vs. goal guidance\n\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = ALPHA * d_from_current + (1 - ALPHA) * d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -7.6266697669819
    }
]