[
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = d_from_current + d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 8,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    ALPHA = 0.6  # Tunable parameter balancing local vs. goal guidance\n\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = ALPHA * d_from_current + (1 - ALPHA) * d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -7.6266697669819
    },
    {
        "sample_order": 15,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unvisited = unvisited_nodes.astype(int)\n    rng = np.random.default_rng(0)  # deterministic for reproducibility\n\n    best_candidate = None\n    best_avg_total = float('inf')\n    num_rollouts = 5  # number of rollout completions to average\n    randomness_prob = 0.1  # probability to take a random tie-breaking choice\n\n    for cand in unvisited:\n        cand = int(cand)\n        remaining = unvisited[unvisited != cand]\n\n        if remaining.size == 0:\n            # Only this candidate remains\n            total_dist = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n            avg_dist = total_dist\n        else:\n            total_dist_sum = 0.0\n            for _ in range(num_rollouts):\n                cur = cand\n                dist = distance_matrix[current_node, cand]\n                rem = remaining.copy()\n                # Greedy completion: at each step, go to the nearest node in rem\n                while rem.size > 0:\n                    rem_int = rem.astype(int)\n                    dists = distance_matrix[cur, rem_int]\n                    min_dist = dists.min()\n                    min_indices = np.where(dists == min_dist)[0]\n                    if min_indices.size > 0:\n                        if rng.random() < randomness_prob:\n                            choice_idx = rng.integers(0, min_indices.size)\n                        else:\n                            choice_idx = 0\n                        next_node = int(rem_int[min_indices[choice_idx]])\n                    else:\n                        next_node = int(rem_int[0])\n                    dist += distance_matrix[cur, next_node]\n                    cur = next_node\n                    rem = rem[rem != next_node]\n                dist += distance_matrix[cur, destination_node]\n                total_dist_sum += dist\n            avg_dist = total_dist_sum / float(num_rollouts)\n\n        if avg_dist < best_avg_total:\n            best_avg_total = avg_dist\n            best_candidate = cand\n\n    return int(best_candidate)\n\n",
        "score": -6.261641814060255
    }
]