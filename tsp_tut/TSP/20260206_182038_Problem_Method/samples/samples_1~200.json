[
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 2,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node][unvisited_nodes]\n    next_node = unvisited_nodes[np.argmin(distances)]\n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 3,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node = unvisited_nodes[np.argmin(distances)]\n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 4,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_distance = float('inf')\n    next_node = -1\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        distance_from_current = distance_matrix[current_node][node]\n        total_distance = distance_to_destination + distance_from_current\n        \n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 5,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 6,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 7,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node][unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 8,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances_to_unvisited = distance_matrix[current_node, unvisited_nodes]\n    estimated_distances = distances_to_unvisited + distance_matrix[unvisited_nodes, destination_node]\n    next_node_index = np.argmin(estimated_distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 9,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmax(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -35.85450182978367
    },
    {
        "sample_order": 10,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    max_distance = -float('inf')\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        \n        if distance_to_destination > max_distance:\n            max_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 11,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_average_distance = float('inf')\n    next_node = -1\n    \n    for node in unvisited_nodes:\n        average_distance = np.mean(distance_matrix[node][unvisited_nodes])\n        \n        if average_distance < min_average_distance:\n            min_average_distance = average_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -30.986766219989573
    },
    {
        "sample_order": 12,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    average_distance = np.mean(distance_matrix[current_node, unvisited_nodes])\n    closest_node = unvisited_nodes[0]\n    min_diff = float('inf')\n    \n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        diff = abs(distance - average_distance)\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_node = node\n            \n    return closest_node\n\n",
        "score": -26.849048901776776
    },
    {
        "sample_order": 13,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    max_distance_index = np.argmax(distances)\n    return unvisited_nodes[max_distance_index]\n\n",
        "score": -35.85450182978367
    },
    {
        "sample_order": 14,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    max_distance = -float('inf')\n    next_node = -1\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        \n        if distance_to_destination > max_distance:\n            max_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 15,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    max_heuristic = -np.inf\n    next_node = None\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node, node]\n        num_unvisited_neighbors = np.sum((distance_matrix[node] < np.inf) & np.isin(np.arange(distance_matrix.shape[0]), unvisited_nodes))\n        \n        heuristic_value = num_unvisited_neighbors - distance_to_destination\n        \n        if heuristic_value > max_heuristic:\n            max_heuristic = heuristic_value\n            next_node = node\n            \n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 16,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    weights = distance_matrix[current_node, unvisited_nodes] + distance_matrix[unvisited_nodes, destination_node]\n    next_node_index = np.argmin(weights)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 17,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    max_min_distance = -float('inf')\n    next_node = -1\n    \n    for node in unvisited_nodes:\n        min_distance = np.min(distance_matrix[node][unvisited_nodes])\n        \n        if min_distance > max_min_distance:\n            max_min_distance = min_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 18,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_distance = float('inf')\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        \n        if distance_to_destination < min_distance:\n            min_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 19,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_distance = float('inf')\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        \n        if distance_to_destination < min_distance:\n            min_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 20,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_distance = float('inf')\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node][destination_node]\n        \n        if distance_to_destination < min_distance:\n            min_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 2,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    closest_node_index = np.argmin(distances)\n    return unvisited_nodes[closest_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 3,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Find the index of the closest unvisited node\n    closest_node_index = np.argmin(distances)\n    \n    # Return the ID of the closest unvisited node\n    return unvisited_nodes[closest_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 4,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node, destination_node]\n        if distance_to_destination < min_distance:\n            min_distance = distance_to_destination\n            next_node = node\n            \n    return next_node\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 5,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 6,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node_index = np.argmin(distances)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 7,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    next_node = unvisited_nodes[np.argmin(distances)]\n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 8,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    \n    # Find the index of the minimum distance\n    next_node_index = np.argmin(distances)\n    \n    # Select the next node\n    next_node = unvisited_nodes[next_node_index]\n    \n    return next_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 9,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    heuristic_values = []\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node, node]\n        total_distance_to_unvisited = np.sum(distance_matrix[node, unvisited_nodes])\n        heuristic_value = distance_to_destination + total_distance_to_unvisited\n        heuristic_values.append(heuristic_value)\n    \n    next_node_index = np.argmin(heuristic_values)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -21.28957607329885
    },
    {
        "sample_order": 10,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    current_distances = distance_matrix[current_node, unvisited_nodes]\n    # Calculate distances from unvisited nodes to the destination node\n    destination_distances = distance_matrix[unvisited_nodes, destination_node]\n    # Calculate a score as a combination of both distances\n    scores = current_distances + destination_distances\n    next_node_index = np.argmin(scores)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 11,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    max_average_distance = -1\n    next_node = unvisited_nodes[0]\n\n    for node in unvisited_nodes:\n        distances_to_other_nodes = distance_matrix[node][unvisited_nodes]\n        average_distance = np.mean(distances_to_other_nodes)\n        \n        if average_distance > max_average_distance:\n            max_average_distance = average_distance\n            next_node = node\n\n    return next_node\n\n",
        "score": -14.655761088719313
    },
    {
        "sample_order": 12,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    return np.abs(node - destination_node)\n\n",
        "score": null
    },
    {
        "sample_order": 13,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    scores = []\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node, destination_node]\n        distance_from_current = distance_matrix[current_node, node]\n        score = distance_to_destination + distance_from_current  # Combine distances\n        scores.append(score)\n    \n    next_node_index = np.argmin(scores)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 14,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    distances = distance_matrix[current_node, unvisited_nodes]\n    min_distance = np.min(distances)\n    closest_nodes = unvisited_nodes[distances == min_distance]\n    selected_node = np.random.choice(closest_nodes)  # Random selection among the closest nodes\n    return selected_node\n\n",
        "score": -6.8239686184057184
    },
    {
        "sample_order": 15,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    closest_nodes = []\n    min_distance = float('inf')\n    \n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node, destination_node]\n        if distance_to_destination < min_distance:\n            min_distance = distance_to_destination\n            closest_nodes = [node]\n        elif distance_to_destination == min_distance:\n            closest_nodes.append(node)\n    \n    return np.random.choice(closest_nodes) if closest_nodes else None\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 16,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_total_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node, node]\n        distance_to_destination = distance_matrix[node, destination_node]\n        total_distance = distance_to_node + distance_to_destination\n        \n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 17,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_average_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        # Calculate average distance to all other unvisited nodes\n        avg_distance = np.mean([distance_matrix[node, other_node] for other_node in unvisited_nodes if other_node != node])\n        \n        if avg_distance < min_average_distance:\n            min_average_distance = avg_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -30.986766219989573
    },
    {
        "sample_order": 18,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    heuristic_values = []\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node, node]\n        average_distance_to_unvisited = np.mean(distance_matrix[node, unvisited_nodes])\n        heuristic_value = distance_to_destination + average_distance_to_unvisited\n        heuristic_values.append(heuristic_value)\n    \n    next_node_index = np.argmin(heuristic_values)\n    return unvisited_nodes[next_node_index]\n\n",
        "score": -8.339550514515025
    },
    {
        "sample_order": 19,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    min_average_distance = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        # Calculate the average distance to all other unvisited nodes\n        distances = distance_matrix[node, unvisited_nodes]\n        average_distance = np.mean(distances)\n        \n        if average_distance < min_average_distance:\n            min_average_distance = average_distance\n            next_node = node\n            \n    return next_node\n\n",
        "score": -30.986766219989573
    },
    {
        "sample_order": 20,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    total_distance = 0\n    count = 0\n    \n    # Calculate the average distance to the destination from unvisited nodes\n    for node in unvisited_nodes:\n        total_distance += distance_matrix[node, destination_node]\n        count += 1\n        \n    average_distance = total_distance / count if count > 0 else float('inf')\n    \n    closest_node = None\n    closest_distance = float('inf')\n\n    # Select the node with a distance closest to the average distance\n    for node in unvisited_nodes:\n        distance_to_destination = distance_matrix[node, destination_node]\n        if abs(distance_to_destination - average_distance) < closest_distance:\n            closest_distance = abs(distance_to_destination - average_distance)\n            closest_node = node\n            \n    return closest_node\n\n",
        "score": -28.46063094706564
    },
    {
        "sample_order": 1,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = d_from_current + d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 2,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    import numpy as np\n\n    # If there are no unvisited nodes left, go directly to the destination\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unvisited = unvisited_nodes\n    # Distances from current node to each unvisited node\n    to_unvisited = distance_matrix[current_node, unvisited]\n    # Distances from each unvisited node to the destination\n    unvisited_to_dest = distance_matrix[unvisited, destination_node]\n    # Score = distance to candidate + distance from candidate to destination\n    scores = to_unvisited + unvisited_to_dest\n\n    next_idx = int(np.argmin(scores))\n    return int(unvisited[next_idx])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 3,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return -1\n\n    best_node = int(unvisited_nodes[0])\n    best_cost = float('inf')\n\n    current = int(current_node)\n    dest = int(destination_node)\n\n    for idx in range(unvisited_nodes.size):\n        cand = int(unvisited_nodes[idx])\n        cost_to_cand = distance_matrix[current, cand]\n        cost_cand_to_dest = distance_matrix[cand, dest]\n        total_cost = cost_to_cand + cost_cand_to_dest\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_node = cand\n\n    return best_node\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 4,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    import numpy as np\n    unvisited = np.asarray(unvisited_nodes)\n    if unvisited.size == 0:\n        return int(destination_node)\n    current = int(current_node)\n    dest = int(destination_node)\n\n    scores = distance_matrix[current, unvisited] + distance_matrix[unvisited, dest]\n    best_index = int(np.argmin(scores))\n    return int(unvisited[best_index])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 5,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    if unvisited_nodes.size == 1:\n        only = int(unvisited_nodes[0])\n        if only == destination_node:\n            return only\n\n    candidates = unvisited_nodes\n    if np.any(candidates == destination_node) and candidates.size > 1:\n        candidates = candidates[candidates != destination_node]\n\n    if candidates.size == 0:\n        return int(destination_node)\n\n    current = int(current_node)\n    dest = int(destination_node)\n\n    scores = []\n    for cand in candidates:\n        cand_int = int(cand)\n        d1 = distance_matrix[current, cand_int]\n        d2 = distance_matrix[cand_int, dest]\n        if np.isnan(d1) or np.isnan(d2):\n            score = np.inf\n        else:\n            score = float(d1 + d2)\n        scores.append(score)\n\n    scores = np.asarray(scores)\n    min_idx = int(np.argmin(scores))\n    return int(candidates[min_idx])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 6,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    # Distances from current to unvisited and from unvisited to destination\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n\n    # Distance from current to destination\n    d_cur_to_dest = distance_matrix[current_node, destination_node]\n\n    # Check which unvisited nodes lie on a shortest path from current to destination\n    on_path_mask = np.isclose(d_from_current + d_to_destination, d_cur_to_dest)\n\n    if np.any(on_path_mask):\n        candidates_on_path = unvisited[on_path_mask]\n        d_from_current_on_path = distance_matrix[current_node, candidates_on_path]\n        next_index = int(np.argmin(d_from_current_on_path))\n        return int(candidates_on_path[next_index])\n\n    # Fallback: pick the unvisited node closest to the destination\n    next_index = int(np.argmin(d_to_destination))\n    return int(unvisited[next_index])\n\n",
        "score": -18.87846365675391
    },
    {
        "sample_order": 7,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n\n    # Lookahead: for each candidate, minimal distance to destination via any intermediate node\n    cand_to_all = distance_matrix[unvisited, :]\n    all_to_dest = distance_matrix[:, destination_node]\n    lookahead = np.min(cand_to_all + all_to_dest[np.newaxis, :], axis=1)\n\n    score = d_from_current + lookahead\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -8.060258218042321
    },
    {
        "sample_order": 8,
        "function": "def select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Design an algorithm to select the next node in each step.\n    Args:\n        current_node    : ID of the current node.\n        destination_node: ID of the destination node.\n        unvisited_nodes : Array of IDs of unvisited nodes.\n        distance_matrix : Distance matrix of nodes.\n    Return:\n        ID of the next node to visit.\n    \"\"\"\n    ALPHA = 0.6  # Tunable parameter balancing local vs. goal guidance\n\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Ensure we are working with integers\n    unvisited = unvisited_nodes.astype(int)\n\n    d_from_current = distance_matrix[current_node, unvisited]\n    d_to_destination = distance_matrix[unvisited, destination_node]\n    score = ALPHA * d_from_current + (1 - ALPHA) * d_to_destination\n\n    next_index = int(np.argmin(score))\n    return int(unvisited[next_index])\n\n",
        "score": -7.6266697669819
    }
]